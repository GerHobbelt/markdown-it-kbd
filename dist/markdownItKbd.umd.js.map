{"version":3,"file":"markdownItKbd.umd.js","sources":["../src/index.ts"],"sourcesContent":["// [[kbd]]\n//\n\n// markdown-it has no types and itâ€™s not worth the effort adding a *.d.ts file\n//import type { MarkdownIt } from '@types/markdown-it';\n\nconst defaultOptions = {\n  MARKER_OPEN: '[[',\n  MARKER_CLOSE: ']]',\n  ESCAPE_CHARACTER: '\\\\',\n  TAG: 'kbd',\n\n  // intern use; derived at time of initialization:\n  MARKER_OPEN_1ST_CHR: 0\n};\n\nexport default function kbdplugin(markdownit, opts): void {\n  const options = Object.assign({}, defaultOptions, opts);\n  options.MARKER_OPEN_1ST_CHR = options.MARKER_OPEN.charCodeAt(0);\n\n\n  function findNextNonEscapedMarker(src, start, marker) {\n    let end;\n    let searchOffset = start;\n    for (;;) {\n      end = src.indexOf(marker, searchOffset);\n      if (end < 0) {\n        return -1;\n      }\n\n      // count number of escape characters before marker:\n      // if ODD, then marker is escaped:\n      let escapeCount = 0;\n      for (let i = end - 1; i >= 0 && src.charAt(i) === options.ESCAPE_CHARACTER; i--) {\n        escapeCount++;\n      }\n      if (escapeCount % 2 === 0) {\n        // got a proper end marker now: exit loop\n        break;\n      }\n      // skip first character of escaped end marker and try again:\n      searchOffset = end + 1;\n    }\n    return end;\n  }\n\n  function findMatchingClose(src, start, level) {\n    let end = findNextNonEscapedMarker(src, start, options.MARKER_CLOSE);\n    if (end < 0) {\n      // no end marker found,\n      // input ended before closing sequence\n      return -1;\n    }\n\n    // first skip all inner KBD chunks:\n    let innerStart = findNextNonEscapedMarker(src, start, options.MARKER_OPEN);\n    let searchOffset = start;\n\n    while (innerStart >= 0) {\n      // when there's a START *before* our END, then that MUST be an *inner* START:\n      // we should find *it's* matching END. That doesn't necessarily have to be\n      // the one we found already, as this stuff may be nested several levels!\n      if (innerStart >= 0 && innerStart < end) {\n        searchOffset = innerStart + options.MARKER_OPEN.length;\n\n        // found one. There may be more. So we move our `end` forward now to ensure the next inner KBD chunk is found as well.\n        end = findMatchingClose(src, searchOffset, level + 1);\n        if (end < 0) {\n          return -1;\n        }\n        searchOffset = end + options.MARKER_CLOSE.length;\n        innerStart = findNextNonEscapedMarker(src, searchOffset, options.MARKER_OPEN);\n        end = findNextNonEscapedMarker(src, searchOffset, options.MARKER_CLOSE);\n        if (end < 0) {\n          // no end marker found,\n          // input ended before closing sequence\n          return -1;\n        }\n      } else {\n        // we only found a START that's beyond our END, so it doesn't matter. Stop looking for inner KBD chunks.\n        innerStart = -1;\n      }\n    }\n\n    // the last END marker found is our own:\n    return end;\n  }\n\n  /*\n   * Add delimiters for double occurrences of MARKER_SYMBOL.\n   */\n  function tokenize(state, silent: boolean) {\n    if (silent) {\n      return false;\n    }\n\n    let start = state.pos;\n    const max = state.posMax;\n    const momChar = state.src.charCodeAt(start);\n\n    // We are looking for two times the open symbol.\n    if (momChar !== options.MARKER_OPEN_1ST_CHR) {\n      return false;\n    }\n    let src = state.src.slice(start);\n    if (!src.startsWith(options.MARKER_OPEN)) {\n      return false;\n    }\n    const startLen = options.MARKER_OPEN.length;\n    start += startLen;\n    src = src.slice(startLen);\n\n    // find the end sequence\n    let end = findMatchingClose(src, 0, 1);\n    if (end < 0) {\n      // no end marker found,\n      // input ended before closing sequence\n      return false;\n    }\n\n    const lf = src.indexOf('\\n');\n    if (lf >= 0 && lf < end) {\n      // found end of line before the end sequence. Thus, ignore our start sequence!\n      return false;\n    }\n\n    // make end position into absolute index\n    end += start;\n\n    // start tag\n    state.push('kbd_open', options.TAG, 1);\n    // parse inner\n    state.pos = start;\n    state.posMax = end;\n    state.md.inline.tokenize(state);\n    state.pos = end + options.MARKER_CLOSE.length;\n    state.posMax = max;\n    // end tag\n    state.push('kbd_close', options.TAG, -1);\n\n    return true;\n  }\n\n\n  markdownit.inline.ruler.before('link', 'kbd', tokenize);\n}\n"],"names":["defaultOptions","MARKER_OPEN","MARKER_CLOSE","ESCAPE_CHARACTER","TAG","MARKER_OPEN_1ST_CHR","kbdplugin","markdownit","opts","options","Object","assign","charCodeAt","findNextNonEscapedMarker","src","start","marker","end","searchOffset","indexOf","escapeCount","i","charAt","findMatchingClose","level","innerStart","length","tokenize","state","silent","pos","max","posMax","momChar","slice","startsWith","startLen","lf","push","md","inline","ruler","before"],"mappings":"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"}