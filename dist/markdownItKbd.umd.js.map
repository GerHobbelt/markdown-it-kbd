{"version":3,"file":"markdownItKbd.umd.js","sources":["../src/index.ts"],"sourcesContent":["// [[kbd]]\n//\n\n// @ts-ignore markdown-it has no types and it’s not worth the effort adding a *.d.ts file\nimport MarkdownIt from 'markdown-it';\n// @ts-ignore markdown-it has no types and it’s not worth the effort adding a *.d.ts file\nimport StateInline from 'markdown-it/lib/rules_inline/state_inline';\n\nlet options = {\n  MARKER_OPEN: '[[',\n  MARKER_CLOSE: ']]',\n  ESCAPE_CHARACTER: '\\\\',\n  TAG: 'kbd',\n\n  // intern use; derived at time of initialization:\n  MARKER_OPEN_1ST_CHR: 0\n};\n\n/*\n * Add delimiters for double occurrences of MARKER_SYMBOL.\n */\nfunction tokenize(state: StateInline, silent: boolean) {\n  if (silent) {\n    return false;\n  }\n\n  let start = state.pos;\n  const max = state.posMax;\n  const momChar = state.src.charCodeAt(start);\n\n  // We are looking for two times the open symbol.\n  if (momChar !== options.MARKER_OPEN_1ST_CHR) {\n    return false;\n  }\n  let src = state.src.slice(start);\n  if (!src.startsWith(options.MARKER_OPEN)) {\n    return false;\n  }\n  const startLen = options.MARKER_OPEN.length;\n  start += startLen;\n  src = src.slice(startLen);\n\n  // find the end sequence\n  let end;\n  let searchOffset = 0;\n  for (;;) {\n    end = src.indexOf(options.MARKER_CLOSE, searchOffset);\n    if (end < 0) {\n    // no end marker found,\n    // input ended before closing sequence\n      return false;\n    }\n\n\t// count number of escape characters before marker:\n\t// if ODD, then marker is escaped:\n    let escapeCount = 0;\n  \tfor (let i = end - 1; i >= 0 && src.charAt(i) === options.ESCAPE_CHARACTER; i--) {\n\t  escapeCount++;\n  \t}\n    if (escapeCount % 2 === 0) {\n  \t  // got a proper end marker now: exit loop\n\t  break;\n    }\n\t// skip first character of escaped end marker and try again:\n    searchOffset = end + 1;\n  }\n\n  const lf = src.indexOf('\\n');\n  if (lf >= 0 && lf < end) {\n    // found end of line before the end sequence. Thus, ignore our start sequence!\n    return false;\n  }\n  const second = src.indexOf(options.MARKER_OPEN);\n  if (second >= 0 && second < end) {\n    // found another opening sequence before the end. Thus, ignore ours!\n    return false;\n  }\n\n  // make end position into absolute index\n  end += start;\n\n  // start tag\n  state.push('kbd_open', options.TAG, 1);\n  // parse inner\n  state.pos = start;\n  state.posMax = end;\n  state.md.inline.tokenize(state);\n  state.pos = end + options.MARKER_CLOSE.length;\n  state.posMax = max;\n  // end tag\n  state.push('kbd_close', options.TAG, -1);\n\n  return true;\n}\n\nexport default function kbdplugin(markdownit: MarkdownIt, opts): void {\n  options = Object.assign(options, opts);\n  options.MARKER_OPEN_1ST_CHR = options.MARKER_OPEN.charCodeAt(0);\n\n  markdownit.inline.ruler.before('link', 'kbd', tokenize);\n}\n"],"names":["options","MARKER_OPEN","MARKER_CLOSE","ESCAPE_CHARACTER","TAG","MARKER_OPEN_1ST_CHR","tokenize","state","silent","start","pos","max","posMax","momChar","src","charCodeAt","slice","startsWith","startLen","length","end","searchOffset","indexOf","escapeCount","i","charAt","lf","second","push","md","inline","kbdplugin","markdownit","opts","Object","assign","ruler","before"],"mappings":"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"}